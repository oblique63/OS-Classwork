\documentclass[12pt]{article}

\usepackage{setspace}
\usepackage{minted}
\usepackage{fancyvrb}
\usepackage{listings}

\usepackage[margin=0.75in]{geometry}
\pagestyle{empty}

\def \name       {Enrique Gavidia}
\def \coursenum  {CSC 415.01}
\def \coursename {Operating Systems Principles}
\def \instructor {Prof. Murphy}
\def \semester   {Spring 2012}
\def \assignment {Homework \# 4}
\def \duedate    {April 4, 2012}

\newcommand {\mytilde} {$\sim$}
\newcommand {\comment}[1] {\textcolor{red}{#1}}
\newcommand {\filename}[1] {\flushleft \textbf{#1}}
\newcommand {\append}[2] {\section*{Appendix #1} \textsl{\large #2}}

\newcommand {\makecover} {
  \begin{titlepage}
    \begin{center}
      \LARGE{\coursenum, \semester \\ \coursename}\\
      \Large{\instructor}\\
      \vfill
      \textbf{\Huge \assignment}\\
      \vfill
      \Large{\name}\\
      \large{\duedate}
    \end{center}
  \end{titlepage}
}

\DefineVerbatimEnvironment {shelloutput} {Verbatim} {fontsize=\scriptsize, numbers=left, frame=lines, commandchars=\%\{\}}

\newcommand {\includesource}[2] {\inputminted[linenos, fontsize=\scriptsize, frame=lines]{#1}{#2}}
\newcommand {\includeoutput}[1] {\VerbatimInput[fontsize=\scriptsize, numbers=left, frame=lines, commandchars=\%\{\}]{#1}}

\begin{document}

\makecover

%---{ Main Content }--------------------------------------------------------------------
\section*{Assignment Description}


% This assignment built off our last one dealing with multiple concurrent processes and threads; however, now we had to prevent the race
% conditions we induced in the last assignment. We were to keep the various design choices that led to the unsynchronized, interleaved output
% (such as the various \texttt{sleep} calls), and wrap them with signal and mutex based synchronization methods; as the goal was now to learn
% about how to ensure that a concurrent program executes how we want it to.  The tasks performed by the concurrent child processes/threads
% (printing out the values from 1-10 [processes], and adding to 100 [threads]) now make up the critical sections of the code, and their execution
% is now managed by semaphores (as described in the \textsl{Pseudo Code} in \textbf{Appendix I}), ensuring a synchronized sequential execution.
% Additionally, we were also asked to induce deadlocks in our newly synchronized solutions, to point out another potential pitfall of concurrent
% programming.
%
% This code has been tested to work under \textsl{Windows}, \textsl{Gentoo Linux}, and \textsl{Mac OSX}.
% The source for the Unix implementation under listed in \textbf{Appendix II}, and \textbf{Appendix IV} for the Windows version.

\section*{Design \& Implementation}

% My goal with the design of my implementations was simply to be clear and concise about the mechanics involved, and what is going on in the code.
% The basic logic for the synchronization closely follows the specifications laid out in the pseudo code for both the Unix and Windows implementations.
% The only minor deviation is in the Windows deadlock version of the threaded program, where I actively lock the mutex in the parent before executing a
% single child (and thus quickly invoke a \texttt{p()}- \texttt{p()} deadlock), as opposed to simply omitting the \texttt{v()} call to send a signal to the following process.
% Aside from that, the Windows and Unix implementations of synchronous multi-threading are virtually identical.

\section*{Testing Strategy}


\section*{Improvements}

% The main improvement I would probably make, would be to rewrite the Unix process synchronization using a fuller semaphore construct, to make it
% clearer to see what is going on logically, as opposed to just using the raw \texttt{kill()} and \texttt{signal()} calls. If the programs were also
% to simply stand on their own as examples of concurrent programming, I would take out the various unnecessary elements that were meant to invoke
% race conditions in the previous assignment (such as the calls to \texttt{sleep()}), to prevent unnecessary confusion about the factors in play
% when synchronizing multiple threads/processes.

%---{ Appendices }-----------------------------------------------------------------------
\newpage
%----{ Pseudo Code }---------------------------------------------------------------------
\append{I} {Pseudo Code}

\filename{Buffer Queue}
\begin{scriptsize}
\begin{verbatim}

BufferQueue {
    Buffer queue;
    int size;
    int count;

    // Counting semaphores
    Semaphore empty;
    Semaphore full;

    // Mutex lock
    Mutex lock;
}

enqueue(buffers) {
    // Wait for some empty buffers
    P(BufferQueue.empty);
    // Lock the mutex
    P(BufferQueue.lock);

    for (buffer in buffers) {
        BufferQueue.count++;
        BufferQueue.queue[BufferQueue.count] = buffer;
    }

    // Unlock the mutex
    V(BufferQueue.lock);
    // Signal the new filled buffers
    V(BufferQueue.full);
}

dequeue(buffers) {
    // Wait for some buffers with values
    P(BufferQueue.full);
    // Lock the mutex
    P(BufferQueue.lock);

    for (buffer in buffers) {
        BufferQueue.count--;
        BufferQueue.queue[BufferQueue.count] = NULL;
    }
    
    // Unlock the mutex
    V(BufferQueue.lock);
    // Signal the new empty buffers
    V(BufferQueue.empty);
}

\end{verbatim}
\end{scriptsize}

\filename{Producer + Consumer}
\begin{scriptsize}
\begin{verbatim}
producer() {
    while (BufferQueue.count < BufferQueue.size) {
        spin_wait();

        enqueue(buffers_to_produce);
    }
}

consumer() {
    while (BufferQueue.count < BufferQueue.size) {
        spin_wait();

        dequeue(buffers_to_consume);
    }
}
\end{verbatim}
\end{scriptsize}


%----{ UNIX }----------------------------------------------------------------------------
\append{II} {Unix Source Code}

\filename{Buffer Queue}
\includesource{c}{unix_buffer_queue.h}

\filename{Unsynchronized}
\includesource{c}{unix_unsynchronized.c}

\filename{Synchronized}
\includesource{c}{unix_synchronized.c}


\append{III} {Unix Output}

\filename{Unsynchronized}
\includeoutput{output/unix_unsynchronized.txt}

\filename{Synchronized}
\includeoutput{output/unix_synchronized.txt}


%----{ WINDOWS }-------------------------------------------------------------------------
\append{IV} {Windows Source Code}

\filename{Buffer Queue}
\includesource{c}{win_buffer_queue.h}

\filename{Unsynchronized}
\includesource{c}{win_unsynchronized.c}

\filename{Synchronized}
\includesource{c}{win_synchronized.c}


\append{V} {Windows Output}

\filename{Unsynchronized}
\includeoutput{output/win_unsynchronized.txt}

\filename{Synchronized}
\includeoutput{output/win_synchronized.txt}


%----{ STRACE }--------------------------------------------------------------------------
\append{VI} {Strace Output}

\filename{Unsynchronized}
\includeoutput{output/unix_unsynchronized_strace.txt}

\filename{Synchronized}
\includeoutput{output/unix_synchronized_strace.txt}

\end{document}
